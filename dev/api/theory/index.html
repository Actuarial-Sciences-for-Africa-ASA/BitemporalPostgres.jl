<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Theory · BitemporalPostgres</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">BitemporalPostgres</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">BitemporalPostgres API</span><ul><li><a class="tocitem" href="../BitemporalPostgres/">BitemporalPostgres</a></li><li><a class="tocitem" href="../BitemporalPostgres.DDL/">DDL</a></li><li class="is-active"><a class="tocitem" href>Theory</a><ul class="internal"><li><a class="tocitem" href="#Twodimensional-intervals-representing-panes-of-validity"><span>Twodimensional intervals representing panes of validity</span></a></li><li><a class="tocitem" href="#Representing-bitemporal-aggregations"><span>Representing bitemporal aggregations</span></a></li><li><a class="tocitem" href="#Textual-representation-of-mutation-histories"><span>Textual representation of mutation histories</span></a></li><li><a class="tocitem" href="#Bitemporal-Transactions"><span>Bitemporal Transactions</span></a></li><li><a class="tocitem" href="#GiST-indexing-in-POSTGRES-for-search-and-guarding-bitemporal-uniqueness"><span>GiST indexing in POSTGRES for search and guarding bitemporal uniqueness</span></a></li><li class="toplevel"><a class="tocitem" href="#A-first-sketch-of-a-bitemporal-UML-model-for-insurance-contracts"><span>A first sketch of a bitemporal UML model for insurance contracts</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">BitemporalPostgres API</a></li><li class="is-active"><a href>Theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Theory</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/michaelfliegner/BitemporalPostgres.jl/blob/master/docs/src/api/theory.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="A-Julia-template-for-Bitemporal-Data-Management-based-on-SearchLight.jl"><a class="docs-heading-anchor" href="#A-Julia-template-for-Bitemporal-Data-Management-based-on-SearchLight.jl">A Julia template for Bitemporal Data Management based on SearchLight.jl</a><a id="A-Julia-template-for-Bitemporal-Data-Management-based-on-SearchLight.jl-1"></a><a class="docs-heading-anchor-permalink" href="#A-Julia-template-for-Bitemporal-Data-Management-based-on-SearchLight.jl" title="Permalink"></a></h1><p>This package provides generic functions for CRUD of bitemporal aggregate entities. Serializing and deserializing is provided by packages JSON and ToStruct.</p><p>The package&#39;s application based transaction logic comprises reified transactions such that even pending transactions&#39; data are persistent. Pending transactions can therefore be suspended, resumed and delegated: passed between users within workflows.</p><h2 id="Twodimensional-intervals-representing-panes-of-validity"><a class="docs-heading-anchor" href="#Twodimensional-intervals-representing-panes-of-validity">Twodimensional intervals representing panes of validity</a><a id="Twodimensional-intervals-representing-panes-of-validity-1"></a><a class="docs-heading-anchor-permalink" href="#Twodimensional-intervals-representing-panes-of-validity" title="Permalink"></a></h2><p>Bitemporal data management models temporal references of data, such as</p><ul><li>a contract&#39;s begin of validity,i.e. from when on it shall be executed</li><li>a contract&#39;s date of signature, or in a computational context: the timestamp of its final (committed) insertion into a database.</li></ul><p>For instance, we agreed</p><ul><li>on Monday on s.th. we call the blue agreement beginning next year,</li><li>on Tuesday on the yellow one beginning two years later, and</li><li>on Wednesday on the red one instead, beginning already one year later</li><li>and leave it at that.</li></ul><p>Our model is to provide answers to questions like</p><p>&quot;What did we think at <em>transaction time</em> what we agreed upon as of <em>referenced time</em>&quot;</p><p>Reference time and transaction time can be seen as constituting a point which is contained in a rectangle of validity and thus identifies a version.</p><p>The first idea of this approach is spatial representation of the two temporal dimensions. The above course of agreements would be described by sets of adjacent rectangles, reference time running horizontally, transaction time vertically and versions eperesented by colour.</p><p><img src="../../assets/ValidityRectangles.png" alt="Areas of Validity"/></p><p>Let&#39;s denote these rectangles by 2dimensional intervals, where <em>lower</em> stands for the start time, which is included, and <em>upper</em> for the end time which is not included. <em>upper</em> = infinity stands for an unspecified end time. We shall use use <em>v</em> to denote the version, i.e. the state of the object&#39;s attribute values that persists in the interval of validity.</p><p>While under this interpretation</p><ul><li>the first dimension allows references to past or future points in time just as human language does,</li><li>the second dimension allows<ul><li>only references to the past for <em>lower</em> as for the assertion to even exist in the data base it must have been entered at some past point of time; and</li><li>references to the past and to infinity for <em>upper</em> as the time of its revocation can be past as well as yet unspecified.</li></ul></li></ul><p class="math-container">\[[d_{lower}, d_{upper}) [w_{lower},w_{upper})\]</p><p>The first, blue, part in the above example is open ended in both dimensions, no end of world validity is intended and no mutation of the data base has been done yet,</p><p class="math-container">\[(v_{blue},[d_{lower},∞ ),[w_{lower},∞) )\]</p><p>The second part, the transition to yellow can be denoted like so:</p><p class="math-container">\[\begin{aligned}
&amp;\text{let} \\
&amp;s_{0} = { (v_{blue},[d_{0},∞ ),[w_{0},∞ ) ) } \\
&amp;t_{1} = (d_{1},w_{1}) \\ 
&amp;\text{where } d_{1} &gt; d_{0}, w_{1} &gt; w_{0} \\
&amp;\text{then mutation of } s_{0} \text{ to yellow per }  t_{1} \text{ equals} \\
\{ &amp;( v_{blue}, [d_{0}, d_{1}), [w_{0},∞), [d_{1},∞), [w_{0},w_{1}) ),\\
&amp; ( v_{yellow}, [d_{1},∞), [w_{1}, ∞) )\}
\end{aligned}\]</p><p>The third part, the mutation overwriting yellow with red, can be denoted like so:</p><p class="math-container">\[\begin{aligned}
&amp;\text{let} \\
&amp;s_{1} =  \{( v_{blue}, [d_{0}, d_{1}), [w_{0},∞), [d_{1},∞), [w_{0},w_{1}) ), ( v_{yellow}, [d_{1},∞), [w_{1}, ∞) )\}\\
&amp;t_{2} = (d_{2},w_{2})\\
&amp;\text{where } d_{2} &gt; d_{1}, w_{2} &lt; w_{1} \\
&amp;\text{then mutation of } s_{1} \text{ to red per }  t_{1} \text{ equals} \\
\end{aligned} \\
\begin{aligned}
\{ &amp;( v_{blue}, [d_{0},d_{1}) [w_{0},∞) [d_{1},d_{2}) [w_{0},w_{1}) [d_{2},∞) [w_{0},w_{2}) ),\\
   &amp;( v_{yellow}, [d_{1},d_{2},) [w_{1},∞) ),\\
   &amp; ( v_{red}, [d_{2},∞) [w_{2},∞) ) \}
\end{aligned}\]</p><h2 id="Representing-bitemporal-aggregations"><a class="docs-heading-anchor" href="#Representing-bitemporal-aggregations">Representing bitemporal aggregations</a><a id="Representing-bitemporal-aggregations-1"></a><a class="docs-heading-anchor-permalink" href="#Representing-bitemporal-aggregations" title="Permalink"></a></h2><p>When we look at bitemporal aggregates we find components that can change independently at different times, like for instance an insurance contract with subobjects like a reference to the premium payer, tariff parameters like height of premium, modes of payment, date of last payment etc.etc.. Thus we find that these subobjects need their own intervals of validity; but because the aggregate changes whenever a component changes, the aggregate version can share its intervals with the changing components. Let&#39;s enhance our example such that we have three components of which</p><ul><li>one is added at creation as of the blue version of the aggregate, but deleted as of the yellow one</li><li>another added at creation as of the yellow version of the aggregate, but deleted as of the red one and</li><li>a third, is added at creation as of the blue version of the aggregate, and kept as of the yellow and red versions</li></ul><p class="math-container">\[\begin{aligned}
h = \{&amp;( v_{blue}, [d_{0},d_{1}) [w_{0},∞) [d_{1},d_{2}) [w_{0},w_{1}) [d_{2},∞) [w_{0},w_{2}) ),\\
      &amp;( v_{yellow}, [d_{1},d_{2},) [w_{1},∞) ),\\
      &amp;( v_{red}, [d_{2},∞) [w_{2},∞) ) \}\\
\\
c_{i} =&amp; ( v_{blue}, [d_{0},d_{1}) [w_{0},∞) [d_{1},d_{2}) [w_{0},w_{1}) [d_{2},∞) [w_{0},w_{2}) )\\
c_{2} =&amp; ( v_{yellow}, [d_{1},d_{2},) [w_{1},∞) )\\
c_{3} =&amp; ( v_{blue}, [d_{0},d_{1}) [w_{0},∞) [d_{1},d_{2}) [w_{0},w_{1}) [d_{2},∞) [w_{0},w_{2}) )( v_{yellow}, [d_{1},d_{2},) [w_{1},∞)(v_{red}, [d_{2},∞) [w_{2},∞) )
\end{aligned}\]</p><p>This can be simplified by substituting the interval sets by references to the versions they are shared with.</p><p class="math-container">\[\begin{aligned}
h = \{&amp;( v_{blue}, [d_{0},d_{1}) [w_{0},∞) [d_{1},d_{2}) [w_{0},w_{1}) [d_{2},∞) [w_{0},w_{2}) ),\\
      &amp;( v_{yellow}, [d_{1},d_{2},) [w_{1},∞) ),\\
      &amp;( v_{red}, [d_{2},∞) [w_{2},∞) ) \} \\
c_{i} =&amp; ( v_{blue})\\
c_{2} =&amp; ( v_{yellow} )\\
c_{3} =&amp; ( v_{blue}, v_{yellow}, v_{red})
\end{aligned}\]</p><p>This is syntactic sugar, but looks better to a programmer, who fears redundancy. But better still  this notation suggests another simplification, by using ranges of versions. Sets of subsequent, contingent (no holes in between) versions can be represented by ranges with the creating version as <em>lower</em> and the invalidating version as <em>upper</em> bound . For the intervals of components that persist,i.e. are not invalidated by a subsequent version, we introduce a pseudo version ∞, which is the greatest upper bound and denotes not invalidated by an exisiting version. This is another joy for the programmer, because creating new versions of the aggregate can be done without updating the upper bounds of intervals of unchanged components.</p><p class="math-container">\[\begin{aligned}
h = \{ &amp;( v_{blue}, [d_{0},d_{1}) [w_{0},∞) [d_{1},d_{2}) [w_{0},w_{1}) [d_{2},∞) [w_{0},w_{2}) ),\\
      &amp;( v_{yellow}, [d_{1},d_{2},) [w_{1},∞) ),\\
      &amp;( v_{red}, [d_{2},∞) [w_{2},∞) ) \}\\
c_{i} =&amp; [v_{blue},v_{yellow})\\
c_{2} =&amp; [v_{yellow},v_{red})\\
c_{3} =&amp; [v_{blue}, v_{∞})
\end{aligned}\]</p><h2 id="Textual-representation-of-mutation-histories"><a class="docs-heading-anchor" href="#Textual-representation-of-mutation-histories">Textual representation of mutation histories</a><a id="Textual-representation-of-mutation-histories-1"></a><a class="docs-heading-anchor-permalink" href="#Textual-representation-of-mutation-histories" title="Permalink"></a></h2><p>A practically interesting aspect of a history of mutations is, which mutations are made to represent consecutive changes of the domain and which ones are retrospective corrections. This can be represented by a tree of vectors of version nodes where</p><ul><li>nodes in one vector denote consecutive mutations and</li><li>child node vectors denote mutations which have been retrospectively corrected by their predecessor</li></ul><p class="math-container">\[\text{let} \\
\begin{aligned}
i=&amp;([t_{0},[t_{1}),[t_{2},t_{3})) \\
shadowed(i) =&amp;\{ ([d_{lower},d_{upper}) [w_{lower},w_{upper}) | d_{upper} = t_{0} \land [w_{lower},w_{upper}) \cap [t_{2},t_{3}) = [w_{lower},w_{upper}) \}
\end{aligned}\]</p><h3 id="textual-represention-of-our-example"><a class="docs-heading-anchor" href="#textual-represention-of-our-example">textual represention of our example</a><a id="textual-represention-of-our-example-1"></a><a class="docs-heading-anchor-permalink" href="#textual-represention-of-our-example" title="Permalink"></a></h3><ul><li>red<ul><li>yellow</li></ul></li><li>blue</li></ul><h2 id="Bitemporal-Transactions"><a class="docs-heading-anchor" href="#Bitemporal-Transactions">Bitemporal Transactions</a><a id="Bitemporal-Transactions-1"></a><a class="docs-heading-anchor-permalink" href="#Bitemporal-Transactions" title="Permalink"></a></h2><h3 id="Transaction-data,-commits-and-rollbacks"><a class="docs-heading-anchor" href="#Transaction-data,-commits-and-rollbacks">Transaction data, commits and rollbacks</a><a id="Transaction-data,-commits-and-rollbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Transaction-data,-commits-and-rollbacks" title="Permalink"></a></h3><p>Transactions here are application based. A transaction is identified by a version and transaction data that depend on it.</p><p><strong>Beginning a transaction</strong> on a bitemporal aggregate now as of a date of reference w means</p><ul><li>to create a version object and</li><li>an interval of validity labelled as not committed and</li></ul><p class="math-container">\[\hspace*{10mm} validity = [now,∞) [w,∞)\]</p><p><strong>Mutations of components</strong> consist of</p><ul><li>new revisions of components that are marked as valid from the new version on and invalid from infinity on and</li><li>previous revisions of mutated or deleted components that are marked as invalid from the new version on.</li></ul><p><strong>Backing out</strong> of a bitemporal transaction consists of</p><ul><li>deleting the version instance and its depending data:<ul><li>the uncommitted interval</li><li>new revisions of components, which are marked as valid from the backed out version on and</li><li>resetting the &quot;invalid from&quot; marks of mutated revisions back to infinity(MaxVersion)</li></ul></li></ul><p><strong>Committing</strong>  a version consists of</p><ul><li>labelling its interval of validity as committed</li><li>and managing shadowing and overlapping of its interval of validity with those of previous versions as is described in above examples.</li></ul><h3 id="Locking"><a class="docs-heading-anchor" href="#Locking">Locking</a><a id="Locking-1"></a><a class="docs-heading-anchor-permalink" href="#Locking" title="Permalink"></a></h3><p>Application defined locking is based on a constraint that per entity only one interval with state uncommitted may exist.</p><h3 id="Reified-transactions-and-workflow"><a class="docs-heading-anchor" href="#Reified-transactions-and-workflow">Reified transactions and workflow</a><a id="Reified-transactions-and-workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Reified-transactions-and-workflow" title="Permalink"></a></h3><p>As transactions in this framework are first class data they can be utilized for workflow control:</p><ul><li>As results of transactionaal operations are persisted immediately, they existence does not depend on the process they are initiated in. The process can be ended before commit and the workflow can resumed later in another process.</li><li>With concepts of <em>ownership of workflow</em> and <em>state of work</em> added, transactions with <em>state of work = suspended</em> marked can  be delegated between owners by suspending and resuming in their respective processes.</li></ul><h2 id="GiST-indexing-in-POSTGRES-for-search-and-guarding-bitemporal-uniqueness"><a class="docs-heading-anchor" href="#GiST-indexing-in-POSTGRES-for-search-and-guarding-bitemporal-uniqueness">GiST indexing in POSTGRES for search and guarding bitemporal uniqueness</a><a id="GiST-indexing-in-POSTGRES-for-search-and-guarding-bitemporal-uniqueness-1"></a><a class="docs-heading-anchor-permalink" href="#GiST-indexing-in-POSTGRES-for-search-and-guarding-bitemporal-uniqueness" title="Permalink"></a></h2><p>Database access to bitemporal objects can be supported by GiST (Generalized Search Tree) indices on our</p><ul><li>timestamp-intervals for database and world validity as well as</li><li>revision intervals</li></ul><p>So in POSTGRES, for example - hava a look at the UML-Diagram below - , we can access a component (with table name <em>PART</em>) by a simple join with filters that locate</p><ul><li>a history&#39;s version by inclusion of the database and world timestamp in thedatabase and world validity intervals and</li><li>a <em>PART</em>&#39;s revision by the version id&#39;s inclusion in the <em>PART_REVISION</em>&#39;s range of valid versions.</li></ul><pre><code>SELECT * FROM histories h
JOIN version v ON v.ref_history = h.id
JOIN validity_interval i ON i.ref_version = v.id 
JOIN <i>PART</i> p ON p.ref_history
JOIN <i>PART_REVISION</i> r ON r.ref_<i>PART</i> = p.id AND r.validity_range  @> v.id
WHERE h.id = :history_id and p.id = :part_id AND i.tsr_world @> TIMESTAMPTZ:ts_world and i.tsr_db @> TIMESTAMPTZ :ts_db
</code></pre><p>POSTGRES also provides uniqueness constraints for GIST-indices, so that we can guarantee for every history, that its versions validity_intervals are unique, that is non overlapping. Inserting an overlapping interval fails constraint violation exception.</p><pre><code>ADD CONSTRAINT bitemp EXCLUDE USING GIST (ref_version WITH =, is_committed WITH =, tsrworld WITH &&, tsrdb WITH &&)`
</code></pre><h1 id="A-first-sketch-of-a-bitemporal-UML-model-for-insurance-contracts"><a class="docs-heading-anchor" href="#A-first-sketch-of-a-bitemporal-UML-model-for-insurance-contracts">A first sketch of a bitemporal UML model for insurance contracts</a><a id="A-first-sketch-of-a-bitemporal-UML-model-for-insurance-contracts-1"></a><a class="docs-heading-anchor-permalink" href="#A-first-sketch-of-a-bitemporal-UML-model-for-insurance-contracts" title="Permalink"></a></h1><p><img src="../../assets/BitemporalModel.uxf.png" alt="UML Model"/></p><p>Please compare: https://hdombrovskaya.wordpress.com/2019/07/14/lets-go-bitemporal/ https://www.postgresql.eu/events/pgdayparis2019/sessions/session/2291/slides/171/pgdayparis<em>2019</em>msedivy_bitemporality.pdf</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../BitemporalPostgres.DDL/">« DDL</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.13 on <span class="colophon-date" title="Tuesday 22 March 2022 07:45">Tuesday 22 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
